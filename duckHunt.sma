/* Plugin generated by AMXX-Studio */

#include < amxmodx >
#include < amxmisc >
#include < hamsandwich >
#include < fakemeta >

#define PLUGIN "Duck Hunt"
#define VERSION "1.0"
#define AUTHOR "DarkGL"

#define MAX 32

enum enumGameState {
	GAME_STARTED	,
	GAME_PAUSE 	,
	GAME_OFF
}

enum enumUserInf {
	enumGameState: gameState	,
	fPositionX 			,
	fPositionY			,
	fAnglesInf[ 3 ]			,
	iPoints
	
}

new userInformation[ MAX + 1 ][ enumUserInf ];

new msgHideWeapon,
	msgCrosshair;

new hudChannelCrosshair;

public plugin_init() {
	register_plugin( PLUGIN , VERSION, AUTHOR );
	
	register_clcmd( "say /duckhunt" , "duckHuntOn" );
	register_clcmd( "say_team /duckhunt" , "duckHuntOn" );
	
	register_clcmd( "say /duckstop" , "duckHuntStop" );
	register_clcmd( "say_team /duckstop" , "duckHuntStop" );
	
	register_clcmd( "say /duckoff" , "duckHuntOff" );
	register_clcmd( "say_team /duckoff" , "duckHuntOff" );
	
	
	RegisterHam( Ham_Killed , "player" , "fwKilled" , 1 );
	RegisterHam( Ham_Spawn , "player" , "fwSpawn" , 1 );
	
	RegisterHam( Ham_Player_PreThink , "player" , "fwPreThink" , 1 );
	
	msgHideWeapon =  get_user_msgid( "HideWeapon" );
	msgCrosshair  =  get_user_msgid( "Crosshair" );
	
	hudChannelCrosshair	=	CreateHudSyncObj();
}

public client_authorized( id ){
	clearUserInformation( id );
}

public client_disconnect( id ){
	clearUserInformation( id );
}

public duckHuntOn( id ){
	if( !is_user_alive( id ) || userInformation[ id ][ gameState ]	!= GAME_OFF ){
		return PLUGIN_HANDLED;
	}
	
	clearUserInformation( id );
	
	userInformation[ id ][ gameState ]	=	GAME_STARTED;
	
	new Float: fAngles[ 3 ] ,
	iTmpAngles[ 3 ];
	
	pev( id , pev_angles , fAngles );
	
	iTmpAngles[ 0 ]	=	_:fAngles[ 0 ];
	iTmpAngles[ 1 ]	=	_:fAngles[ 1 ];
	iTmpAngles[ 2 ]	=	_:fAngles[ 2 ];
	
	copy( userInformation[ id ][ fAnglesInf ] , 3 , iTmpAngles );
	
	return PLUGIN_HANDLED;
}

public duckHuntStop( id ){
	if( userInformation[ id ][ gameState ]	==	GAME_OFF ){
		return PLUGIN_HANDLED;
	}
	
	userInformation[ id ][ gameState ]	=	userInformation[ id ][ gameState ] == GAME_STARTED ? GAME_PAUSE : GAME_STARTED ;
	
	return PLUGIN_HANDLED;
}

public duckHuntOff( id ){
	if( userInformation[ id ][ gameState ]	==	GAME_OFF ){
		return PLUGIN_HANDLED;
	}
	
	userInformation[ id ][ gameState ]	=	GAME_OFF;
	
	return PLUGIN_HANDLED;
}

public fwKilled( id ){
	if( is_user_alive( id ) ){
		return HAM_IGNORED;
	}
	
	clearUserInformation( id );
	
	return HAM_IGNORED;
}

public fwSpawn( id ){
	if( !is_user_alive( id ) ){
		return HAM_IGNORED;
	}
	
	clearUserInformation( id );
	
	return HAM_IGNORED;
}

public fwPreThink( id ){
	if( userInformation[ id ][ gameState ] 	== 	GAME_OFF ){
		return HAM_IGNORED;
	}
	
	displayFade( id , 1 , 1 , 0 ,  0 , 0 , 0 , 255 );
	
	message_begin( MSG_ONE_UNRELIABLE, msgHideWeapon , _, id );
	write_byte( ( 1<<0 ) | (1<<3) | (1<<4) | (1<<5) | (1<<1) );
	message_end();
	
	message_begin( MSG_ONE_UNRELIABLE, msgCrosshair, _, id );
	write_byte( 0 );
	message_end( );
	
	new Float: fAngles[ 3 ];
	
	pev( id , pev_angles , fAngles )
	
	if( userInformation[ id ][ gameState ]	==	GAME_STARTED ) {
		
		if( fAngles[ 1 ] >  Float:userInformation[ id ][ fAnglesInf ][ 1 ] && Float:userInformation[ id ][ fPositionX ] > 0.0 ){
			userInformation[ id ][ fPositionX ] = _:( Float:userInformation[ id ][ fPositionX ] - 0.01 );
		}
		else if(  fAngles[ 1 ] < Float:userInformation[ id ][ fAnglesInf ][ 1 ] && Float:userInformation[ id ][ fPositionX ] < 1.0 ){
			userInformation[ id ][ fPositionX ] = _:( Float:userInformation[ id ][ fPositionX ] + 0.01 );
		}
		
		if( fAngles[ 0 ]  >   Float:userInformation[ id ][ fAnglesInf ][ 0 ]  && Float:userInformation[ id ][ fPositionX ] > 0.0 ){
			userInformation[ id ][ fPositionY ] = _:( Float:userInformation[ id ][ fPositionY ] - 0.01 );
		}
		else if( fAngles[ 0 ] <   Float:userInformation[ id ][ fAnglesInf ][ 0 ]  && Float:userInformation[ id ][ fPositionY ] < 1.0 ){
			userInformation[ id ][ fPositionY ] = _:( Float:userInformation[ id ][ fPositionY ] + 0.01 );
		}
	}
	
	client_print( id , print_chat , "%f | %f" , Float:userInformation[ id ][ fAnglesInf ][ 0 ] , Float:userInformation[ id ][ fAnglesInf ][ 1 ] )
	client_print( id , print_chat , "%f | %f" , fAngles[ 0 ] , fAngles[ 1 ] )
	
	fAngles[ 0 ]	=	Float:userInformation[ id ][ fAnglesInf ][ 0 ];
	fAngles[ 1 ]	=	Float:userInformation[ id ][ fAnglesInf ][ 1 ];
	fAngles[ 2 ]	=	Float:userInformation[ id ][ fAnglesInf ][ 2 ];
	
	set_pev( id , pev_angles , fAngles );
	set_pev( id , pev_fixangle , 1 );
	
	set_hudmessage( 0 , 255 , 0 , Float:userInformation[ id ][ fPositionX ] , Float:userInformation[ id ][ fPositionY ] , 0 , 1.0 , 1.0 , 1.0 ,1.0 );
	ShowSyncHudMsg( id , hudChannelCrosshair , "   |   ^n--- ---^n   |   " );
	
	return HAM_IGNORED;
}

clearUserInformation( id ){
	userInformation[ id ][ fPositionX ]	=	_:0.5;
	userInformation[ id ][ fPositionY ]	=	_:0.5;
	
	userInformation[ id ][ gameState ]	=	GAME_OFF;
	
	copy( userInformation[ id ][ fAnglesInf ] , 3 , { _:0.0 , _:0.0 , _:0.0 } )
}

displayFade(id,duration,holdtime,fadetype,red,green,blue,alpha){
	
	static msgScreenFade;
	
	if( !msgScreenFade ) msgScreenFade = get_user_msgid("ScreenFade")
	
	message_begin( !id ? MSG_ALL : MSG_ONE, msgScreenFade,{0,0,0},id );
	write_short( (1<<12) * duration );
	write_short( (1<<12) * holdtime );
	write_short( fadetype );  
	write_byte ( red );      
	write_byte ( green );
	write_byte ( blue );      
	write_byte ( alpha );      
	message_end();
}

stock playSound( id , sound[] ){
	if( !is_user_connected(id) ) return PLUGIN_HANDLED
	
	client_cmd(id,"mp3 play %s",sound)
	
	return PLUGIN_CONTINUE
}